#pragma once

// internal
#include "common.hpp"

// stlib
#include <vector>
#include <random>
#include <map>
#include <string>

#define SDL_MAIN_HANDLED
#include <SDL.h>
#include <SDL_mixer.h>
#include <box2d/box2d.h>

#include "render_system.hpp"
#include <random>

// Global Variables
extern bool grapplePointActive; // Bool to check if grapple is on a grapple point
extern bool grappleActive;		// Bool to check if grapple is active

// Container for all our entities and game logic.
// Individual rendering / updates are deferred to the update() methods.
class WorldSystem
{
public:
	explicit WorldSystem(b2WorldId world);

	// creates main window
	GLFWwindow *create_window();

	// starts and loads music and sound effects
	bool start_and_load_sounds();

	// call to close the window
	void close_window();

	bool is_in_goal();

	// starts the game
	void init(RenderSystem *renderer);

	// releases all associated resources
	~WorldSystem();

	// steps the game ahead by ms milliseconds
	bool step(float elapsed_ms);

	// check for collisions generated by the physics system
	void handle_collisions();

	// should the game be over ?
	bool is_over() const;

	// vignete fade out control
	float vignette_timer_ms = 0.0f;

	// level loading
	bool load_level(const std::string &filename);

	GLFWwindow *getWindow()
	{
		return window;
	}

	RenderSystem *renderer;

private:
	// Selected level
	int level_selection = 1;

	// Number of (destructible) enemies to kill
	int num_enemies_to_kill = -1;

	// box2d world instance (shared between systems)
	b2WorldId worldId;

	// used for tracking key states for smoother movement
	std::unordered_map<int, bool> keyStates;

	float mouse_pos_x = 0.0f;
	float mouse_pos_y = 0.0f;
	// Game state
	float current_speed;

	// grid
	std::vector<Entity> grid_lines;
	std::vector<Entity> lines;

	// music references
	Mix_Music *background_music;
	Mix_Music *background_music_memorybranch;
	Mix_Music *background_music_oblanka;
	Mix_Music *background_music_paradrizzle;
	Mix_Music *background_music_windcatcher;
	Mix_Music *background_music_promenade;
	Mix_Music *background_music_spaba;
	Mix_Music *background_music_cottonplanes;
	Mix_Music *background_music_pencilcrayons;
	Mix_Music *background_music_moontownshores;

	// fx references
	Mix_Chunk *fx_destroy_enemy;
	Mix_Chunk *fx_destroy_enemy_fail;
	Mix_Chunk *fx_jump;
	Mix_Chunk *fx_grapple;
	Mix_Chunk *fx_victory;
	Mix_Chunk *chicken_dead_sound;
	Mix_Chunk *chicken_eat_sound;

	// audio control
	void playMusic(MUSIC music);
	void playSoundEffect(FX effect);

	// player movement
	void handle_movement(float elapsed_ms);
	void update_isGrounded();

	// C++ random number generator
	std::default_random_engine rng;
	std::uniform_real_distribution<float> uniform_dist; // number between 0..1

	// input callback functions
	void on_key(int key, int, int action, int mod);
	void on_mouse_move(vec2 pos);
	void on_mouse_button_pressed(int button, int action, int mods);

	// stop game (when an invader reaches right side of screen)
	void stop_game();

	// lock the game state if true (when an invader reaches the right side of the screen)
	bool game_active = true;

	// restart level
	void restart_game(int level);

	// prototype for generating chain terrain
	void generateTestTerrain();
	std::vector<b2Vec2> generateTestPoints();

	// OpenGL window handle
	GLFWwindow *window;

	// LEVEL MAP
	// KEY: (int) Level
	// VALUE: Tuple < (string) levelMapFilePath, (enum) Level_Texture, (enum) Level_Music >
	// Inside tuple we put:
	// - File path for the level map
	// - Texture asset for the level
	// - Music for the level

	const std::map<int,
				   std::tuple<
					   std::string,
					   TEXTURE_ASSET_ID,
					   MUSIC>>
		levelMap =
			{
				// ADD LEVELS HERE
				// tmj files
				{1, {"level1.tmj", TEXTURE_ASSET_ID::LEVEL_1, MUSIC::PROMENADE}},
				{2, {"level2.tmj", TEXTURE_ASSET_ID::LEVEL_2, MUSIC::PROMENADE}},
				{3, {"level3.tmj", TEXTURE_ASSET_ID::LEVEL_3, MUSIC::PROMENADE}},
				{4, {"level4.tmj", TEXTURE_ASSET_ID::LEVEL_4, MUSIC::PROMENADE}},
				{5, {"level5.tmj", TEXTURE_ASSET_ID::LEVEL_5, MUSIC::PROMENADE}},
				{6, {"level6.tmj", TEXTURE_ASSET_ID::LEVEL_6, MUSIC::PROMENADE}},
				{7, {"tutorial.tmj", TEXTURE_ASSET_ID::LEVEL_TUTORIAL, MUSIC::PARADRIZZLE}},
				{8, {"tower.tmj", TEXTURE_ASSET_ID::LEVEL_TOWER, MUSIC::WINDCATCHER}},
				{9, {"lab.tmj", TEXTURE_ASSET_ID::LEVEL_LAB, MUSIC::COTTONPLANES}},
				{10, {"under.tmj", TEXTURE_ASSET_ID::LEVEL_UNDER, MUSIC::SPABA}},
				{11, {"snake.tmj", TEXTURE_ASSET_ID::LEVEL_SNAKE, MUSIC::PENCILCRAYONS}},
				{12, {"tunnelsmall.tmj", TEXTURE_ASSET_ID::LEVEL_TUNNELSMALL, MUSIC::MOONTOWNSHORES}}

				// How to Add Levels:
				// 1. Add both TMJ (/levels) and PNG (/data/textures/levels) to the project
				// 2. Add TMJ file, asset, and music here
				// 3. Add ASSET_ID in components.hpp
				// 4. Load map texture in render_system.hpp
	};

	// NOTE THAT ALL POSITIONS ARE GRID COORDINATES!!!
	// Takes:
	// - Enemy Spawn Area
	// - Enemy type/number to spawn
	// - Location to spawn enemy
	// - Patrol area if it's an obstacle
	// Returns:
	// - Handles enemy spawning according to specs.
	void insertToSpawnMap(ivec2 bottom_left, ivec2 top_right,
						  ENEMY_TYPES enemy_type, int num_enemies,
						  ivec2 spawn_location,
						  ivec2 obstacle_patrol_bottom_left, ivec2 obstacle_patrol_top_right);

	// Spawn map:
	//	key is a vector<int> (tile that triggers spawn),
	//	value is a tuple with:
	// 1. ENEMY_TYPE denoting type of enemy to spawn
	// 2. Int denoting quantity of enemies to spawn
	// 3. Boolean denoting spawnMap
	// 4. Boolean denoting hasEnemyAlreadySpawned (at this tile)
	// 5. vector<int> denoting spawn position
	// 6. vector<int> denoting patrol range on the X-axis
	std::map<
		std::vector<int>,	  // KEY
		std::tuple<			  // VALUE
			ENEMY_TYPES,	  // 1
			int,			  // 2
			bool,			  // 3
			bool,			  // 4
			std::vector<int>, // 5
			std::vector<int>  // 6
			>>
		spawnMap;
	// call map helper to insert into this map.

	int next_enemy_spawn;
	int enemy_spawn_rate_ms; // see default value in common.hpp

	int max_towers; // see default value in common.hpp

	// Player reached finish line (DEFAULT TO FALSE AND SET TO TRUE IF THEY GOT THERE!!!)
	bool player_reached_finish_line = false; // LLNOTE: make sure to set this to true once player reaches finish line.
	// Timer before end of game screen is displayed
	int timer_game_end_screen = TIMER_GAME_END;
	// Enemies killed.
	int enemies_killed = 0;
	// Player hp.
	int hp = PLAYER_STARTING_HP;

	// Frames per second
	int fps = 0; // 0 is default val
	// Do an FPS cooldown to prevent flickering
	float fps_update_cooldown_ms = FPS_UPDATE_COOLDOWN_MS;

	// Time elapsed
	int time_elapsed = 0;
	// Time cooldown to prevent flickering (also determines granularity of time)
	int time_granularity = TIME_GRANULARITY;

	// vignette fade out control
	void trigger_vignette(float duration) { vignette_timer_ms = duration; }

	// clock for timer
	std::chrono::steady_clock::time_point game_start_time;

	// use this to handle enemy spawning.
	/*
	INPUTS
	- predicate: condition on which to spawn the enemies.
	- enemy_type: type of enemy to spawn.
	- quantity: number of enemies to spawn.
	- position: where to spawn the enemy.
	- movement_area: this applies to OBSTACLE enemies only. Dictates the upper and lower bounds for x-coordinates on which it can move.
	*/
	void handleEnemySpawning(ENEMY_TYPES enemy_type, int quantity, ivec2 gridPosition, ivec2 grid_patrol_point_a, ivec2 grid_patrol_point_b);

	// use this to check if the player has reached a specified grid coordinate. (recall GRID_CELL_WIDTH, GRID_CELL_HEIGHT)
	// Note that the ivec4
	bool checkPlayerReachedArea(ivec2 area_bottom_left, ivec2 area_top_right);

	vec2 screenToWorld(vec2 mouse_position);
	void checkGrappleGrounded();

	// Handles logic for level.
	void levelHelper(int level);

	// Returns total number of (destructible) enemies per level.
	int countEnemiesOnLevel();

	// NOT NEEDED IF WE JUST FREEZE PHYSICS!!! (in fact it's better if we froze physics as original velocity preserved
	// Freezes everything when game is paused.
	void freezeMovements();

	// Checks if the game is over and sets the screen as needed based on whether the player won or lost.
	void handleGameover(CurrentScreen &currentScreen);

	// LLNOTE: FOR CODE READABILITY, ALL OF THE SCREEN ELEMENT AND BUTTON CREATIONS SHOULD BE IN HERE.
	// Handles the creation of screen elements.
	void createScreenElements();

	// Handles button presses based on the function of said button.
	void handleButtonPress(std::string function);
	void shootGrapplePoint();
	void shootGrapple(vec2 worldMousePos);
	void updateScore(Entity scoreEntity);
	void updateTimer(long long time_elapsed);
};
