#pragma once

// internal
#include "common.hpp"

// stlib
#include <vector>
#include <random>
#include <map>

#define SDL_MAIN_HANDLED
#include <SDL.h>
#include <SDL_mixer.h>
#include <box2d/box2d.h>

#include "render_system.hpp"
#include <random>

// Global Variables
extern bool grapplePointActive; // Bool to check if grapple is on a grapple point
extern bool grappleActive;		// Bool to check if grapple is active

// Container for all our entities and game logic.
// Individual rendering / updates are deferred to the update() methods.
class WorldSystem
{
public:
	explicit WorldSystem(b2WorldId world);

	// creates main window
	GLFWwindow *create_window();

	// starts and loads music and sound effects
	bool start_and_load_sounds();

	// call to close the window
	void close_window();

	// starts the game
	void init(RenderSystem *renderer);

	// releases all associated resources
	~WorldSystem();

	// steps the game ahead by ms milliseconds
	bool step(float elapsed_ms);

	// check for collisions generated by the physics system
	void handle_collisions();

	// should the game be over ?
	bool is_over() const;

	// vignete fade out control
	float vignette_timer_ms = 0.0f;

	GLFWwindow *getWindow()
	{
		return window;
	}

private:
	// box2d world instance (shared between systems)
	b2WorldId worldId;

	// used for tracking key states for smoother movement
	std::unordered_map<int, bool> keyStates;

	float mouse_pos_x = 0.0f;
	float mouse_pos_y = 0.0f;

	// Game state
	RenderSystem *renderer;
	float current_speed;

	// grid
	std::vector<Entity> grid_lines;
	std::vector<Entity> lines;

	// music references
	Mix_Music *background_music;
	Mix_Chunk *chicken_dead_sound;
	Mix_Chunk *chicken_eat_sound;

	// player movement
	void handle_movement(float elapsed_ms);
	void update_isGrounded();

	// C++ random number generator
	std::default_random_engine rng;
	std::uniform_real_distribution<float> uniform_dist; // number between 0..1

	// input callback functions
	void on_key(int key, int, int action, int mod);
	void on_mouse_move(vec2 pos);
	void on_mouse_button_pressed(int button, int action, int mods);

	// stop game (when an invader reaches right side of screen)
	void stop_game();

	// lock the game state if true (when an invader reaches the right side of the screen)
	bool game_active = true;

	// restart level
	void restart_game();

	// prototype for generating chain terrain
	void generateTestTerrain();
	std::vector<b2Vec2> generateTestPoints();

	// OpenGL window handle
	GLFWwindow *window;

	// LLNOTE
	// Updated map:
	//	key is a vector<int> (tile that triggers spawn),
	//	value is a tuple with:
	// 1. ENEMY_TYPE denoting type of enemy to spawn
	// 2. Int denoting quantity of enemies to spawn
	// 3. Boolean denoting hasPlayerReachedTile
	// 4. Boolean denoting hasEnemyAlreadySpawned (at this tile)
	// 5. vector<int> denoting spawn position
	// 6. vector<int> denoting patrol range on the X-axis
	std::map<
		std::vector<int>,	  // KEY
		std::tuple<			  // VALUE
			ENEMY_TYPES,	  // 1
			int,			  // 2
			bool,			  // 3
			bool,			  // 4
			std::vector<int>, // 5
			std::vector<int>  // 6
			>>
		hasPlayerReachedTile = {
			{{17, 6},
			 {ENEMY_TYPES::OBSTACLE,
			  1,
			  false,
			  false,
			  {26, 5},
			  {23, 28}}},
			{{33, 6},
			 {ENEMY_TYPES::SWARM,
			  20,
			  false,
			  false,
			  {42, 8},
			  {0, 0}}},
			{{50, 6},
			 {ENEMY_TYPES::COMMON,
			  3,
			  false,
			  false,
			  {68, 5},
			  {0, 0}}}};

	int next_enemy_spawn;
	int enemy_spawn_rate_ms; // see default value in common.hpp

	int max_towers; // see default value in common.hpp

	// Number of invaders stopped by the towers, displayed in the window title
	int points;

	// Frames per second
	int fps = 0; // 0 is default val
	// Do an FPS cooldown to prevent flickering
	float fps_update_cooldown_ms = FPS_UPDATE_COOLDOWN_MS;

	// vignette fade out control
	void trigger_vignette(float duration) { vignette_timer_ms = duration; }

	// use this to handle enemy spawning.
	/*
	INPUTS
	- predicate: condition on which to spawn the enemies.
	- enemy_type: type of enemy to spawn.
	- quantity: number of enemies to spawn.
	- position: where to spawn the enemy.
	- movement_area: this applies to OBSTACLE enemies only. Dictates the upper and lower bounds for x-coordinates on which it can move.
	*/
	void handleEnemySpawning(ENEMY_TYPES enemy_type, int quantity, ivec2 gridPosition, ivec2 gridPatrolXRange);

	// use this to check if the player has reached a specified grid coordinate. (recall GRID_CELL_WIDTH, GRID_CELL_HEIGHT)
	bool checkPlayerReachedTile(ivec2 grid_coordinate);

	vec2 screenToWorld(vec2 mouse_position);
	void checkGrappleGrounded();
	void shootGrapplePoint();
	void shootGrapple(vec2 worldMousePos);
};
