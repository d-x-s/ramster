#pragma once

// internal
#include "common.hpp"

// stlib
#include <vector>
#include <random>

#define SDL_MAIN_HANDLED
#include <SDL.h>
#include <SDL_mixer.h>
#include <box2d/box2d.h>

#include "render_system.hpp"

// Global Variables
extern bool grappleActive; // Bool to check if grapple is active

// Container for all our entities and game logic.
// Individual rendering / updates are deferred to the update() methods.
class WorldSystem
{
public:
	explicit WorldSystem(b2WorldId world);

	// creates main window
	GLFWwindow* create_window();

	// starts and loads music and sound effects
	bool start_and_load_sounds();

	// call to close the window
	void close_window();

	// starts the game
	void init(RenderSystem* renderer);

	// releases all associated resources
	~WorldSystem();

	// steps the game ahead by ms milliseconds
	bool step(float elapsed_ms);

	// check for collisions generated by the physics system
	void handle_collisions();

	// should the game be over ?
	bool is_over() const;

	// vignete fade out control
	float vignette_timer_ms = 0.0f;

	GLFWwindow* getWindow() {
		return window;
	}

private:
	// box2d world instance (shared between systems)
	b2WorldId worldId;

	// used for tracking key states for smoother movement
	std::unordered_map<int, bool> keyStates;

	float mouse_pos_x = 0.0f;
	float mouse_pos_y = 0.0f;

	// Game state
	RenderSystem* renderer;
	float current_speed;

	// grid
	std::vector<Entity> grid_lines;
	std::vector<Entity> lines;

	// music references
	Mix_Music* background_music;
	Mix_Chunk* chicken_dead_sound;
	Mix_Chunk* chicken_eat_sound;

	// player movement
	void handle_movement();
	void update_isGrounded();

	// C++ random number generator
	std::default_random_engine rng;
	std::uniform_real_distribution<float> uniform_dist; // number between 0..1

	// input callback functions
	void on_key(int key, int, int action, int mod);
	void on_mouse_move(vec2 pos);
	void on_mouse_button_pressed(int button, int action, int mods);

	// stop game (when an invader reaches right side of screen)
	void stop_game();

	// lock the game state if true (when an invader reaches the right side of the screen)
	bool game_active = true;

	// restart level
	void restart_game();

	// prototype for generating chain terrain
	void generateTestTerrain();
	std::vector<b2Vec2> generateTestPoints();

	// OpenGL window handle
	GLFWwindow* window;

	int next_enemy_spawn;
	int enemy_spawn_rate_ms;	// see default value in common.hpp

	int max_towers;	// see default value in common.hpp

	// Number of invaders stopped by the towers, displayed in the window title
	int points;

	// Frames per second
	int fps = 0; // 0 is default val
	// Do an FPS cooldown to prevent flickering
	float fps_update_cooldown_ms = FPS_UPDATE_COOLDOWN_MS;

	// vignette fade out control
	void trigger_vignette(float duration) { vignette_timer_ms = duration; }

	vec2 screenToWorld(vec2 mouse_position);
	void attachGrapple();
	void checkGrappleGrounded();
	// use this to handle enemy spawning.
	/*
	INPUTS
	- predicate: condition on which to spawn the enemies.
	- enemy_type: type of enemy to spawn.
	- quantity: number of enemies to spawn.
	- position: where to spawn the enemy.
	- movement_area: this applies to OBSTACLE enemies only. Dictates the upper and lower bounds for x-coordinates on which it can move.
	*/
	void handleEnemySpawning(bool predicate, ENEMY_TYPES enemy_type, int quantity, vec2 position, vec2 movement_area);

	// update grapple hook line
	void updateGrappleLines();

};
