#pragma once

// internal
#include "common.hpp"

// stlib
#include <vector>
#include <random>
#include <map>
#include <string>

#define SDL_MAIN_HANDLED
#include <SDL.h>
#include <SDL_mixer.h>
#include <box2d/box2d.h>

#include "render_system.hpp"
#include <random>

// Global Variables
extern bool grappleActive; // Bool to check if grapple is active

// Container for all our entities and game logic.
// Individual rendering / updates are deferred to the update() methods.
class WorldSystem
{
public:
	explicit WorldSystem(b2WorldId world);

	// creates main window
	GLFWwindow* create_window();

	// starts and loads music and sound effects
	bool start_and_load_sounds();

	// call to close the window
	void close_window();

	// starts the game
	void init(RenderSystem* renderer);

	// releases all associated resources
	~WorldSystem();

	// steps the game ahead by ms milliseconds
	bool step(float elapsed_ms);

	// check for collisions generated by the physics system
	void handle_collisions();

	// should the game be over ?
	bool is_over() const;

	// vignete fade out control
	float vignette_timer_ms = 0.0f;

	// level loading
	bool load_level(const std::string& filename);

	GLFWwindow* getWindow() {
		return window;
	}

	RenderSystem* renderer;

private:

	// Selected level
	int level_selection = 1;

	// Number of (destructible) enemies to kill
	int num_enemies_to_kill = -1;

	// box2d world instance (shared between systems)
	b2WorldId worldId;

	// used for tracking key states for smoother movement
	std::unordered_map<int, bool> keyStates;

	float mouse_pos_x = 0.0f;
	float mouse_pos_y = 0.0f;
	// Game state
  float current_speed;

	// grid
	std::vector<Entity> grid_lines;
	std::vector<Entity> lines;

	// music references
	Mix_Music* background_music;
  Mix_Music* background_music_memorybranch;
  Mix_Music* background_music_oblanka;
  Mix_Music* background_music_paradrizzle;
  Mix_Music* background_music_windcatcher;

  // fx references
  Mix_Chunk* fx_destroy_enemy;
  Mix_Chunk* fx_destroy_enemy_fail;
  Mix_Chunk* fx_jump;
  Mix_Chunk* fx_grapple;
	Mix_Chunk* chicken_dead_sound;
	Mix_Chunk* chicken_eat_sound;

  // audio control
  void playMusic(MUSIC music);
  void playSoundEffect(FX effect);

	// player movement
	void handle_movement();
	void update_isGrounded();

	// C++ random number generator
	std::default_random_engine rng;
	std::uniform_real_distribution<float> uniform_dist; // number between 0..1

	// input callback functions
	void on_key(int key, int, int action, int mod);
	void on_mouse_move(vec2 pos);
	void on_mouse_button_pressed(int button, int action, int mods);

	// stop game (when an invader reaches right side of screen)
	void stop_game();

	// lock the game state if true (when an invader reaches the right side of the screen)
	bool game_active = true;

	// restart level
	void restart_game(MUSIC music, std::string level);

	// prototype for generating chain terrain
	void generateTestTerrain();
	std::vector<b2Vec2> generateTestPoints();

	// OpenGL window handle
	GLFWwindow* window;

	// NOTE THAT ALL POSITIONS ARE GRID COORDINATES!!!
	// Takes:
	// - Enemy Spawn Area
	// - Enemy type/number to spawn
	// - Location to spawn enemy
	// - Patrol area if it's an obstacle
	// Returns:
	// - Handles enemy spawning according to specs.
	void insertToSpawnMap(ivec2 bottom_left, ivec2 top_right, 
							ENEMY_TYPES enemy_type, int num_enemies, 
							ivec2 spawn_location, 
							ivec2 obstacle_patrol_bottom_left, ivec2 obstacle_patrol_top_right);

	// Updated map: 
	//	key is a vector<int> (tile that triggers spawn), 
	//	value is a tuple with:
	// 1. ENEMY_TYPE denoting type of enemy to spawn
	// 2. Int denoting quantity of enemies to spawn
	// 3. Boolean denoting spawnMap
	// 4. Boolean denoting hasEnemyAlreadySpawned (at this tile)
	// 5. vector<int> denoting spawn position
	// 6. vector<int> denoting patrol range on the X-axis
	std::map<
		std::vector<int>,		// KEY
		std::tuple<				// VALUE
			ENEMY_TYPES,			// 1
			int,					// 2
			bool,					// 3
			bool,					// 4
			std::vector<int>,		// 5
			std::vector<int>		// 6
		>
	> spawnMap;
	// call map helper to insert into this map.

	int next_enemy_spawn;
	int enemy_spawn_rate_ms;	// see default value in common.hpp

	int max_towers;	// see default value in common.hpp

	// Player reached finish line (DEFAULT TO FALSE AND SET TO TRUE IF THEY GOT THERE!!!)
	int player_reached_finish_line = true; //LLNOTE: Set this to true so game can actually end without finish lines, will set to false later.
	// Enemies killed.
	int enemies_killed;
	// Player hp. 
	int hp = PLAYER_STARTING_HP;

	// Frames per second
	int fps = 0; // 0 is default val
	// Do an FPS cooldown to prevent flickering
	float fps_update_cooldown_ms = FPS_UPDATE_COOLDOWN_MS;

	// Time elapsed
	int time_elapsed = 0; 
	// Time cooldown to prevent flickering (also determines granularity of time)
	int time_granularity = TIME_GRANULARITY;

	// vignette fade out control
	void trigger_vignette(float duration) { vignette_timer_ms = duration; }

	// use this to handle enemy spawning.
	/*
	INPUTS
	- predicate: condition on which to spawn the enemies.
	- enemy_type: type of enemy to spawn.
	- quantity: number of enemies to spawn.
	- position: where to spawn the enemy.
	- movement_area: this applies to OBSTACLE enemies only. Dictates the upper and lower bounds for x-coordinates on which it can move.
	*/
	void handleEnemySpawning(ENEMY_TYPES enemy_type, int quantity, ivec2 gridPosition, ivec2 grid_patrol_point_a, ivec2 grid_patrol_point_b);

	
	// use this to check if the player has reached a specified grid coordinate. (recall GRID_CELL_WIDTH, GRID_CELL_HEIGHT)
	// Note that the ivec4
	bool checkPlayerReachedArea(ivec2 area_bottom_left, ivec2 area_top_right);

	vec2 screenToWorld(vec2 mouse_position);
	void attachGrapple();
	void checkGrappleGrounded();

	// Handles logic for level.
	void levelHelper(int level);

	// Returns total number of (destructible) enemies per level.
	int countEnemiesOnLevel();

	// NOT NEEDED IF WE JUST FREEZE PHYSICS!!! (in fact it's better if we froze physics as original velocity preserved
	// Freezes everything when game is paused.
	void freezeMovements();
};
